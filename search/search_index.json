{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAPI-Redis-Cache-Reborn","text":""},{"location":"#introduction","title":"Introduction","text":"<p>A simple and robust caching solution for FastAPI that interprets request header values and creates proper response header values (powered by Redis)</p> <p>This project is a continuation of fastapi-redis-cache which seems to no longer be maintained and had fallen behind in both Redis and FastAPI versions. I decided to split this as a separate repository rather than a fork, since the original project has had no activity for a over three years.</p> <p>Right now the code is basically the same as the original project, but I have updated the Package management system to use Poetry, the dependencies and the CI/CD pipeline, and added type-hinting. I've also merged some open PRs from the original project that fixed some issues.</p> <p>See the TODO File file for a list of things I plan to do in the near future.</p> <p>The package still has the same interface and classes as the original. You will still import the package as <code>fastapi_redis_cache</code> in your code, the name has only changed on PyPI to avoid conflicts with the original package. This is to make it transparent to migrate to this version.</p> <p>Important</p> <p>It is important to make sure that the old package is uninstalled before installing this one. The package name has changed, but the module name is still <code>fastapi_redis_cache</code>. The best way is to remove your old virtual environment and run <code>poetry install</code> or <code>pip install</code> again.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Cache response data for async and non-async path operation functions.</li> <li>Lifetime of cached data is configured separately for each API endpoint.</li> <li>Requests with <code>Cache-Control</code> header containing <code>no-cache</code> or <code>no-store</code> are   handled correctly (all caching behavior is disabled).</li> <li>Requests with <code>If-None-Match</code> header will receive a response with status <code>304 NOT   MODIFIED</code> if ETag for requested resource matches header value.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>This is an auto-generated log of all the changes that have been made to the project since the first release, with the latest changes at the top.</p> <p>This project adheres to Semantic Versioning.</p>"},{"location":"changelog/#030-june-04-2024","title":"0.3.0 (June 04, 2024)","text":"<p>'It's Alive!!!!'</p> <p>This is the first release of the project since the fork from the original. It includes some changes and fixes but otherise is the same functionality as the original, though with modernized dependencies and tooling.</p> <p>New Features</p> <ul> <li>Update docker file to use <code>redis/redis-stack</code> (#20) by seapagan</li> <li>Add a 'tag' parameter to the 'cache' decorator for future functionality (#16) by seapagan</li> <li>Run mypy as a GitHub Action (#10) by seapagan</li> <li>Support more object types (#9) by seapagan</li> </ul> <p>Bug Fixes</p> <ul> <li>FIX content-length header gets incorrectly set to 0 by default (#8) by seapagan</li> </ul> <p>Refactoring</p> <ul> <li>Fix Linting and Typing issues (#5) by seapagan</li> <li>Migrate tooling and libraries (#3) by seapagan</li> </ul> <p>Documentation</p> <ul> <li>Add a changelog generator to the project (#13) by seapagan</li> <li>Add Python 'Trove' classifiers to the project (#12) by seapagan</li> <li>Rename project and update README (#11) by seapagan</li> </ul> <p>Dependency Updates</p> <ul> <li>Bump requests from 2.31.0 to 2.32.2 (#82) by dependabot[bot]</li> <li>Bump jinja2 from 3.1.3 to 3.1.4 (#81) by dependabot[bot]</li> <li>Bump faker from 24.14.0 to 25.4.0 (#80) by dependabot[bot]</li> <li>Bump ruff from 0.4.2 to 0.4.7 (#79) by dependabot[bot]</li> <li>Bump pymarkdownlnt from 0.9.18 to 0.9.20 (#78) by dependabot[bot]</li> <li>Bump pytest from 8.1.2 to 8.2.1 (#73) by dependabot[bot]</li> <li>Bump fakeredis from 2.22.0 to 2.23.2 (#72) by dependabot[bot]</li> <li>Bump pre-commit from 3.7.0 to 3.7.1 (#70) by dependabot[bot]</li> <li>Bump pyfakefs from 5.4.1 to 5.5.0 (#69) by dependabot[bot]</li> <li>Bump jinja2 from 3.1.3 to 3.1.4 (#63) by dependabot[bot]</li> <li>and 35 more dependency updates</li> </ul> <p>This changelog was generated using github-changelog-md by Seapagan</p>"},{"location":"contributing/","title":"Contributing to the Project","text":"<p>Thank you for your interest in contributing to <code>fastapi-redis-cache-reborn</code>! We welcome all contributions, big or small.</p> <p>If you are not sure where to start, please take a look at the open issues. If you have an idea for a new feature or would like to report a bug, please open a new issue. You can also check the TODO List for ideas.</p> <p>I also welcome contributions to the documentation. If you find any errors or would like to suggest improvements, please open a new issue or submit a Pull Request.</p> <p>I you would like to contribute to the code, but find the requirements below a bit daunting, please feel free to open a discussion and I can help you get started, or even pair on a PR.</p> <p>Currently, development is done primary on Linux, but I will also try to test on Windows and Mac OS X when possible. If you are using a different platform and find any issues, please let me know. I welcome any contributions, on any platform!</p> <p>If you have any issues developing on a particular platform, please let me know and I will try to help you out. I am also open to suggestions for improving the development process and documentation.</p>"},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>Since this is a Python project, you will need to have Python installed on your machine. You can download the latest version of Python from the official website or using your Operating system's package manager. This project requires Python 3.9 or higher.</p> <p>I'd recommend using pyenv to manage your Python installations, the pyenv-installer works for Linux and Mac OS X. For Windows, you can use the pyenv-win port. See here for installation instructions.</p> <p>We also use Poetry to manage our dependencies. You should have this installed as well. You can install Poetry by following the instructions on the Poetry website.</p> <p>Tip</p> <p>If you don't want to have Poetry installed globally for any reason, there is an auto-generated <code>requirements-dev.txt</code> file in the root of the project. You can use this to install the dependencies using <code>pip</code>:</p> <pre><code>$ pip install -r requirements-dev.txt\n</code></pre> <p>With this, <code>Poetry</code> is also installed as a dependency for <code>poe</code> anyway so you may as well use it ! It's a great tool and I highly recommend it. Also, it is an integral part of this project development.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<p>Before you start contributing, please make sure you have read and understood our Code of Conduct and License.</p> <p>To get started, follow these steps:</p> <ol> <li>Fork the repository and clone it to your local machine.</li> <li>Install the required dependencies (see next section).</li> <li>Create a new branch for your changes: <code>git checkout -b my-new-feature</code>.</li> <li>Make your changes and commit them: <code>git commit -am 'Add some feature'</code>.</li> <li>Push your changes to your fork: <code>git push origin my-new-feature</code>.</li> <li>Create a new pull request.</li> </ol>"},{"location":"contributing/#install-dependencies","title":"Install Dependencies","text":"<p>Run the following command to install the required dependencies:</p> <pre><code>poetry install\n</code></pre> <p>You then need to activate the virtual environment:</p> <pre><code>poetry shell\n</code></pre> <p>From here you can start working on the project. If you are using an IDE such as VSCode or PyCharm, you can set the use their Python interpreter setting to use the virtual environment that has just been created.</p>"},{"location":"contributing/#linting","title":"Linting","text":"<p>I am quite strict about linting and code formatting and have set up a number of pre-commit hooks and tasks to ensure that the code meets the required standards.</p>"},{"location":"contributing/#install-git-pre-commit-hooks","title":"Install Git Pre-Commit hooks","text":"<p>Please install this if you are intending to submit a PR. It will check commits locally before they are pushed up to the Repo. The GitHub CI runs the linting checks (and in future probably MyPy as well), and will fail if there are any errors.</p> <pre><code>$ pre-commit install\npre-commit installed at .git/hooks/pre-commit\n</code></pre> <p>This will ensure that all code meets the required linting standard before being committed.</p>"},{"location":"contributing/#run-pre-commit-manually","title":"Run pre-commit manually","text":"<p>You can run these checks manually on all staged files using the below command :</p> <pre><code>poe pre\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<p>We are using pytest for testing.</p> <p>If you add any new features, please add tests for them. This will help us to ensure that the code is working as expected and will prevent any regressions.</p> <p>GitHub Actions will run the tests on every commit and PR, failing tests will block the PR from being merged.</p> <p>There is a task set up to run tests:</p> <pre><code>poe test\n</code></pre> <p>You can also run the tests manually using the following command:</p> <pre><code>pytest\n</code></pre> <p>The task is set up so we can automatically add other options in the future.</p>"},{"location":"contributing/#changelog","title":"Changelog","text":"<p>The changelog is automatically generated, using this project, so please do not edit it manually.</p> <p>For maintainers, there is a POE task that will run this and update the changelog file.</p> <pre><code>poe changelog\n</code></pre> <p>You would also need to add a GitHub Personal Access Token to a local config file as usual. See the section in the Documentation for information.</p> <p>However, you should NOT include a change to the <code>CHANGELOG.md</code> file in any Pull Requests. This will be handled by the maintainers when a new release is made. Your GitHub username will be added to the changelog automatically beside your PR.</p>"},{"location":"contributing/#convenience-tasks","title":"Convenience Tasks","text":"<p>There are a few other convenience tasks that can be run using the <code>poe</code> command. These are defined in the <code>pyproject.toml</code> file.</p> <p>Each of these tasks can have extra options added which will be passed to the underlying tool.</p> <p>Run <code>mypy</code> on the code base in strict mode:</p> <pre><code>poe mypy\n</code></pre> <p>Format the code using <code>ruff format</code>:</p> <pre><code>poe format\n</code></pre> <p>Lint the code using <code>ruff</code>:</p> <pre><code>poe ruff\n</code></pre> <p>Check the Markdown:</p> <pre><code>poe markdown\n</code></pre> <p>Run <code>ruff</code>, <code>mypy</code>, <code>format</code> and <code>markdown</code> at the same time:</p> <pre><code>poe lint\n</code></pre>"},{"location":"contributing/#documentation-tasks","title":"Documentation Tasks","text":"<p>These are to help with developing and updating the documentation.</p> <ul> <li><code>poe docs:serve</code> - Serve the MkDocs locally for testing and development</li> <li><code>poe docs:serve:all</code> - Same as above, but opens to all interfaces so you can   view it on other devices on your network</li> <li><code>poe docs:build</code> - Build the MkDocs site into the <code>dist</code> folder</li> <li><code>poe docs:publish</code> - Publish the docs to your GitHub pages. Note that only   those with write-access to this repo can do this.</li> </ul>"},{"location":"contributing/#guidelines","title":"Guidelines","text":"<p>Here are some guidelines to follow when contributing to <code>fastapi-redis-cache-reborn</code>:</p> <ul> <li>Follow the PEP 8 style guide. The   pre-commit hooks will check for this. We are using the Ruff   Formatter.</li> <li>Fix any linting errors or warnings. The pre-commit hooks will check for   this also. Ruff is installed and set to pretty   strict settings. Ruff now replaces all the original linters that were   installed. There is also a Markdown linter.</li> <li>MyPy is installed and we are using   type hints. Please try to add type hints to your code. If you see any areas of   the code that are missing type hints, please feel free to open a PR and add   them \ud83d\ude01!</li> <li>Write clear and concise commit messages.</li> <li>Write tests for your code.</li> <li>Make sure your code passes all existing and new tests before submitting a pull   request.</li> <li>Document your code using   docstrings. This project uses the   Google Docstring   Spec though   at this time is a bit slack on listing the Args and Returns. I will be adding   these in as I go along so feel free to add them in if you are contributing   .</li> <li>If you add or change any functionality, please update the documentation   accordingly.</li> <li>Use GitHub   issues to   report bugs or suggest new features.</li> </ul> <p>If you are using VSCode, there is a config file in the <code>.vscode</code> folder that will help you to follow these guidelines. You may need to install some extensions to get the most out of it. I'll add a list of recommended extensions here soon. The <code>Python</code> and <code>Ruff</code> ones are very helpful (the included <code>.vscode</code> folder helps configure these).</p>"},{"location":"contributing/#contact","title":"Contact","text":"<p>If you have any questions or need help with contributing, please contact me @seapagan on GitHub. You can also use the GitHub Discussions feature.</p> <p>Happy contributing!</p>"},{"location":"installation/","title":"Installation","text":"<p>To add <code>fastapi-redis-cache-reborn</code> to your project, you can use <code>poetry</code> or <code>pip</code>.</p> <p>if you are using <code>poetry</code> (recommended):</p> <pre><code>poetry add fastapi-redis-cache-reborn\n</code></pre> <p>Otherwise you can use <code>pip</code>:</p> <pre><code>pip install fastapi-redis-cache-reborn\n</code></pre>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2020 Aaron Luna\nCopyright (c) 2024 Grant Ramsay (seapagan)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"todo/","title":"TODO List","text":""},{"location":"todo/#existing-issues","title":"Existing Issues","text":"<p>These below are from Issues or PRs in the original repository.</p> <ul> <li>Add ability to manually expire a cache entry   (https://github.com/a-luna/fastapi-redis-cache/issues/63)</li> <li>Add support for caching non-FastAPI functions   (https://github.com/a-luna/fastapi-redis-cache/pull/66)</li> <li>Take a look at other issues in the original repository to see if any need to   be added here.</li> </ul>"},{"location":"todo/#new-ideas","title":"New Ideas","text":"<ul> <li>add an option to the init function to disable logging of cache hits and   misses. or only display these messages if a certain ENV variable is set/unset?</li> <li>add an option to have a separate logging file for cache hits and misses?</li> <li>remove creating a test Redis from <code>redis.py</code>. This should not be done in the   production logic, but set up in the test logic.</li> <li>remove the FakeRedis from the <code>_connect_</code> function. This should be set up in   the test logic not production code.</li> <li>catch invalid cache type exceptions and raise a more informative error   message.</li> </ul>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#redis-server","title":"Redis Server","text":"<p>You will need access to a Redis server. If you don't have one running locally, you can use <code>Docker</code> or even a cloud service like Redis Cloud or AWS ElastiCache.</p> <p>There is a <code>docker-compose-redis-only.yml</code> file in the root of this repository that you can use to start a Redis server locally. Just run:</p> <pre><code>docker compose -f docker-compose-redis-only.yml up -d\n</code></pre> <p>This will spin up a Redis server on <code>localhost:6379</code>, without any password, running in the background. You can stop it with:</p> <pre><code>docker compose -f docker-compose-redis-only.yml down\n</code></pre> <p>The image is based on redis/redis-stack so also includes RedisInsight running on port <code>8001</code> that you can use to inspect the Redis server.</p> <p>Note that this is a development server and should not be used in production.</p>"},{"location":"usage/#initialize-redis-in-your-fastapi-application","title":"Initialize Redis in your FastAPI application","text":"<p>Create a <code>FastApiRedisCache</code> instance when your application starts by defining a Lifespan event handler as shown below. Replace the <code>REDIS_SERVER_URL</code> with the address and port of your own Redis server.</p> <pre><code>import os\n\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI, Request, Response\nfrom fastapi_redis_cache import FastApiRedisCache, cache\nfrom sqlalchemy.orm import Session\n\nREDIS_SERVER_URL = \"redis://127.0.0.1:6379\"\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    redis_cache = FastApiRedisCache()\n    redis_cache.init(\n        host_url=os.environ.get(\"REDIS_URL\", REDIS_SERVER_URL),\n        prefix=\"myapi-cache\",\n        response_header=\"X-MyAPI-Cache\",\n        ignore_arg_types=[Request, Response, Session]\n    )\n    yield\n\napp = FastAPI(title=\"FastAPI Redis Cache Example\",lifespan=lifespan)\n\n# routes and more code\n</code></pre> <p>After creating the instance, you must call the <code>init</code> method. The only required argument for this method is the URL for the Redis database (<code>host_url</code>). All other arguments are optional:</p> <ul> <li><code>host_url</code> (<code>str</code>) \u2014 Redis database URL. (Required)</li> <li><code>prefix</code> (<code>str</code>) \u2014 Prefix to add to every cache key stored in the Redis   database. (Optional, defaults to <code>None</code>)</li> <li><code>response_header</code> (<code>str</code>) \u2014 Name of the custom header field used to   identify cache hits/misses. (Optional, defaults to <code>X-FastAPI-Cache</code>)</li> <li><code>ignore_arg_types</code> (<code>List[Type[object]]</code>) \u2014 Cache keys are created (in   part) by combining the name and value of each argument used to invoke a path   operation function. If any of the arguments have no effect on the response   (such as a <code>Request</code> or <code>Response</code> object), including their type in this list   will ignore those arguments when the key is created. (Optional, defaults to   <code>[Request, Response]</code>)</li> <li>The example shown here includes the <code>sqlalchemy.orm.Session</code> type, if your   project uses SQLAlchemy as a dependency (as demonstrated in the FastAPI   docs),   you should include <code>Session</code> in <code>ignore_arg_types</code> in order for cache keys to   be created correctly (More info).</li> </ul>"},{"location":"usage/#cache-decorator","title":"<code>@cache</code> Decorator","text":"<p>Decorating a path function with <code>@cache</code> enables caching for the endpoint. Response data is only cached for <code>GET</code> operations, decorating path functions for other HTTP method types will have no effect. If no arguments are provided, responses will be set to expire after one year, which, historically, is the correct way to mark data that \"never expires\".</p> <pre><code># WILL NOT be cached\n@app.get(\"/data_no_cache\")\ndef get_data():\n    return {\"success\": True, \"message\": \"this data is not cacheable, for... you know, reasons\"}\n\n# Will be cached for one year\n@app.get(\"/immutable_data\")\n@cache()\nasync def get_immutable_data():\n    return {\"success\": True, \"message\": \"this data can be cached indefinitely\"}\n</code></pre> <p>Response data for the API endpoint at <code>/immutable_data</code> will be cached by the Redis server. Log messages are written to standard output whenever a response is added to or retrieved from the cache:</p> <pre><code>INFO:fastapi_redis_cache:| 04/21/2021 12:26:26 AM | CONNECT_BEGIN: Attempting to connect to Redis server...\nINFO:fastapi_redis_cache:| 04/21/2021 12:26:26 AM | CONNECT_SUCCESS: Redis client is connected to server.\nINFO:fastapi_redis_cache:| 04/21/2021 12:26:34 AM | KEY_ADDED_TO_CACHE: key=api.get_immutable_data()\nINFO:     127.0.0.1:61779 - \"GET /immutable_data HTTP/1.1\" 200 OK\nINFO:fastapi_redis_cache:| 04/21/2021 12:26:45 AM | KEY_FOUND_IN_CACHE: key=api.get_immutable_data()\nINFO:     127.0.0.1:61779 - \"GET /immutable_data HTTP/1.1\" 200 OK\n</code></pre> <p>The log messages show two successful (<code>200 OK</code>) responses to the same request (<code>GET /immutable_data</code>). The first request executed the <code>get_immutable_data</code> function and stored the result in Redis under key <code>api.get_immutable_data()</code>. The second request did not execute the <code>get_immutable_data</code> function, instead the cached result was retrieved and sent as the response.</p> <p>In most situations, response data must expire in a much shorter period of time than one year. Using the <code>expire</code> parameter, You can specify the number of seconds before data is deleted:</p> <pre><code># Will be cached for thirty seconds\n@app.get(\"/dynamic_data\")\n@cache(expire=30)\ndef get_dynamic_data(request: Request, response: Response):\n    return {\"success\": True, \"message\": \"this data should only be cached temporarily\"}\n</code></pre> <p>Note</p> <p><code>expire</code> can be either an <code>int</code> value or <code>timedelta</code> object. When the TTL is very short (like the example above) this results in a decorator that is expressive and requires minimal effort to parse visually. For durations an hour or longer (e.g., <code>@cache(expire=86400)</code>), IMHO, using a <code>timedelta</code> object is much easier to grok (<code>@cache(expire=timedelta(days=1))</code>).</p>"},{"location":"usage/#response-headers","title":"Response Headers","text":"<p>A response from the <code>/dynamic_data</code> endpoint showing all header values is given below:</p> <pre><code>$ http \"http://127.0.0.1:8000/dynamic_data\"\n  HTTP/1.1 200 OK\n  cache-control: max-age=29\n  content-length: 72\n  content-type: application/json\n  date: Wed, 21 Apr 2021 07:54:33 GMT\n  etag: W/-5480454928453453778\n  expires: Wed, 21 Apr 2021 07:55:03 GMT\n  server: uvicorn\n  x-fastapi-cache: Hit\n\n  {\n      \"message\": \"this data should only be cached temporarily\",\n      \"success\": true\n  }\n</code></pre> <ul> <li>The <code>x-fastapi-cache</code> header field indicates that this response was found in   the Redis cache (a.k.a. a <code>Hit</code>). The only other possible value for this field   is <code>Miss</code>.</li> <li>The <code>expires</code> field and <code>max-age</code> value in the <code>cache-control</code> field indicate   that this response will be considered fresh for 29 seconds. This is expected   since <code>expire=30</code> was specified in the <code>@cache</code> decorator.</li> <li>The <code>etag</code> field is an identifier that is created by converting the response   data to a string and applying a hash function. If a request containing the   <code>if-none-match</code> header is received, any <code>etag</code> value(s) included in the   request will be used to determine if the data requested is the same as the   data stored in the cache. If they are the same, a <code>304 NOT MODIFIED</code> response   will be sent. If they are not the same, the cached data will be sent with a   <code>200 OK</code> response.</li> </ul> <p>These header fields are used by your web browser's cache to avoid sending unnecessary requests. After receiving the response shown above, if a user requested the same resource before the <code>expires</code> time, the browser wouldn't send a request to the FastAPI server. Instead, the cached response would be served directly from disk.</p> <p>Of course, this assumes that the browser is configured to perform caching. If the browser sends a request with the <code>cache-control</code> header containing <code>no-cache</code> or <code>no-store</code>, the <code>cache-control</code>, <code>etag</code>, <code>expires</code>, and <code>x-fastapi-cache</code> response header fields will not be included and the response data will not be stored in Redis.</p>"},{"location":"usage/#pre-defined-lifetimes","title":"Pre-defined Lifetimes","text":"<p>The decorators listed below define several common durations and can be used in place of the <code>@cache</code> decorator:</p> <ul> <li><code>@cache_one_minute</code></li> <li><code>@cache_one_hour</code></li> <li><code>@cache_one_day</code></li> <li><code>@cache_one_week</code></li> <li><code>@cache_one_month</code></li> <li><code>@cache_one_year</code></li> </ul> <p>For example, instead of <code>@cache(expire=timedelta(days=1))</code>, you could use:</p> <pre><code>from fastapi_redis_cache import cache_one_day\n\n@app.get(\"/cache_one_day\")\n@cache_one_day()\ndef partial_cache_one_day(response: Response):\n    return {\"success\": True, \"message\": \"this data should be cached for 24 hours\"}\n</code></pre> <p>If a duration that you would like to use throughout your project is missing from the list, you can easily create your own:</p> <pre><code>from functools import partial, update_wrapper\nfrom fastapi_redis_cache import cache\n\nONE_HOUR_IN_SECONDS = 3600\n\ncache_two_hours = partial(cache, expire=ONE_HOUR_IN_SECONDS * 2)\nupdate_wrapper(cache_two_hours, cache)\n</code></pre> <p>Then, simply import <code>cache_two_hours</code> and use it to decorate your API endpoint path functions:</p> <pre><code>@app.get(\"/cache_two_hours\")\n@cache_two_hours()\ndef partial_cache_two_hours(response: Response):\n    return {\"success\": True, \"message\": \"this data should be cached for two hours\"}\n</code></pre>"},{"location":"usage/#cache-keys","title":"Cache Keys","text":"<p>Consider the <code>/get_user</code> API route defined below. This is the first path function we have seen where the response depends on the value of an argument (<code>id: int</code>). This is a typical CRUD operation where <code>id</code> is used to retrieve a <code>User</code> record from a database. The API route also includes a dependency that injects a <code>Session</code> object (<code>db</code>) into the function, per the instructions from the FastAPI docs:</p> <pre><code>@app.get(\"/get_user\", response_model=schemas.User)\n@cache(expire=3600)\ndef get_user(id: int, db: Session = Depends(get_db)):\n    return db.query(models.User).filter(models.User.id == id).first()\n</code></pre> <p>In the Initialize Redis section of this document, the <code>FastApiRedisCache.init</code> method was called with <code>ignore_arg_types=[Request, Response, Session]</code>. Why is it necessary to include <code>Session</code> in this list?</p> <p>Before we can answer that question, we must understand how a cache key is created. If the following request was received: <code>GET /get_user?id=1</code>, the cache key generated would be <code>myapi-cache:api.get_user(id=1)</code>.</p> <p>The source of each value used to construct this cache key is given below:</p> <ol> <li>The optional <code>prefix</code> value provided as an argument to the    <code>FastApiRedisCache.init</code> method =&gt; <code>\"myapi-cache\"</code>.</li> <li>The module containing the path function =&gt; <code>\"api\"</code>.</li> <li>The name of the path function =&gt; <code>\"get_user\"</code>.</li> <li>The name and value of all arguments to the path function EXCEPT for    arguments with a type that exists in <code>ignore_arg_types</code> =&gt; <code>\"id=1\"</code>.</li> </ol> <p>Since <code>Session</code> is included in <code>ignore_arg_types</code>, the <code>db</code> argument was not included in the cache key when Step 4 was performed.</p> <p>If <code>Session</code> had not been included in <code>ignore_arg_types</code>, caching would be completely broken. To understand why this is the case, see if you can figure out what is happening in the log messages below:</p> <pre><code>INFO:uvicorn.error:Application startup complete.\nINFO:fastapi_redis_cache.client: 04/23/2021 07:04:12 PM | KEY_ADDED_TO_CACHE: key=myapi-cache:api.get_user(id=1,db=&lt;sqlalchemy.orm.session.Session object at 0x11b9fe550&gt;)\nINFO:     127.0.0.1:50761 - \"GET /get_user?id=1 HTTP/1.1\" 200 OK\nINFO:fastapi_redis_cache.client: 04/23/2021 07:04:15 PM | KEY_ADDED_TO_CACHE: key=myapi-cache:api.get_user(id=1,db=&lt;sqlalchemy.orm.session.Session object at 0x11c7f73a0&gt;)\nINFO:     127.0.0.1:50761 - \"GET /get_user?id=1 HTTP/1.1\" 200 OK\nINFO:fastapi_redis_cache.client: 04/23/2021 07:04:17 PM | KEY_ADDED_TO_CACHE: key=myapi-cache:api.get_user(id=1,db=&lt;sqlalchemy.orm.session.Session object at 0x11c7e35e0&gt;)\nINFO:     127.0.0.1:50761 - \"GET /get_user?id=1 HTTP/1.1\" 200 OK\n</code></pre> <p>The log messages indicate that three requests were received for the same endpoint, with the same arguments (<code>GET /get_user?id=1</code>). However, the cache key that is created is different for each request:</p> <pre><code>KEY_ADDED_TO_CACHE: key=myapi-cache:api.get_user(id=1,db=&lt;sqlalchemy.orm.session.Session object at 0x11b9fe550&gt;\nKEY_ADDED_TO_CACHE: key=myapi-cache:api.get_user(id=1,db=&lt;sqlalchemy.orm.session.Session object at 0x11c7f73a0&gt;\nKEY_ADDED_TO_CACHE: key=myapi-cache:api.get_user(id=1,db=&lt;sqlalchemy.orm.session.Session object at 0x11c7e35e0&gt;\n</code></pre> <p>The value of each argument is added to the cache key by calling <code>str(arg)</code>. The <code>db</code> object includes the memory location when converted to a string, causing the same response data to be cached under three different keys! This is obviously not what we want.</p> <p>The correct behavior (with <code>Session</code> included in <code>ignore_arg_types</code>) is shown below:</p> <pre><code>INFO:uvicorn.error:Application startup complete.\nINFO:fastapi_redis_cache.client: 04/23/2021 07:04:12 PM | KEY_ADDED_TO_CACHE: key=myapi-cache:api.get_user(id=1)\nINFO:     127.0.0.1:50761 - \"GET /get_user?id=1 HTTP/1.1\" 200 OK\nINFO:fastapi_redis_cache.client: 04/23/2021 07:04:12 PM | KEY_FOUND_IN_CACHE: key=myapi-cache:api.get_user(id=1)\nINFO:     127.0.0.1:50761 - \"GET /get_user?id=1 HTTP/1.1\" 200 OK\nINFO:fastapi_redis_cache.client: 04/23/2021 07:04:12 PM | KEY_FOUND_IN_CACHE: key=myapi-cache:api.get_user(id=1)\nINFO:     127.0.0.1:50761 - \"GET /get_user?id=1 HTTP/1.1\" 200 OK\n</code></pre> <p>Now, every request for the same <code>id</code> generates the same key value (<code>myapi-cache:api.get_user(id=1)</code>). As expected, the first request adds the key/value pair to the cache, and each subsequent request retrieves the value from the cache based on the key.</p>"},{"location":"usage/#cache-keys-pt-2","title":"Cache Keys Pt 2","text":"<p>What about this situation? You create a custom dependency for your API that performs input validation, but you can't ignore it because it does have an effect on the response data. There's a simple solution for that, too.</p> <p>Here is an endpoint from one of my projects:</p> <pre><code>@router.get(\"/scoreboard\", response_model=ScoreboardSchema)\n@cache()\ndef get_scoreboard_for_date(\n    game_date: MLBGameDate = Depends(), db: Session = Depends(get_db)\n):\n    return get_scoreboard_data_for_date(db, game_date.date)\n</code></pre> <p>The <code>game_date</code> argument is a <code>MLBGameDate</code> type. This is a custom type that parses the value from the querystring to a date, and determines if the parsed date is valid by checking if it is within a certain range. The implementation for <code>MLBGameDate</code> is given below:</p> <pre><code>class MLBGameDate:\n    def __init__(\n        self,\n        game_date: str = Query(..., description=\"Date as a string in YYYYMMDD format\"),\n        db: Session = Depends(get_db),\n    ):\n        try:\n            parsed_date = parse_date(game_date)\n        except ValueError as ex:\n            raise HTTPException(status_code=400, detail=ex.message)\n        result = Season.is_date_in_season(db, parsed_date)\n        if result.failure:\n            raise HTTPException(status_code=400, detail=result.error)\n        self.date = parsed_date\n        self.season = convert_season_to_dict(result.value)\n\n    def __str__(self):\n        return self.date.strftime(\"%Y-%m-%d\")\n</code></pre> <p>Please note the <code>__str__</code> method that overrides the default behavior. This way, instead of <code>&lt;MLBGameDate object at 0x11c7e35e0&gt;</code>, the value will be formatted as, for example, <code>2019-05-09</code>. You can use this strategy whenever you have an argument that has en effect on the response data but converting that argument to a string results in a value containing the object's memory location.</p>"}]}